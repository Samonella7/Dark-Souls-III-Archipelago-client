#include <functional>

#include "AutoEquip.h"
#include "Core.h"
#include "GameHook.h"
#include "ItemRandomiser.h"
#include "ItemInfo.h"

extern CCore* Core;
extern CItemRandomiser* ItemRandomiser;
extern CGameHook* GameHook;
extern CAutoEquip* AutoEquip;
extern CItemInfo* ItemInfo;

void CItemRandomiser::HookedItemGib(void* mapItemMan, SItemBuffer* pItemBuffer, int32_t* pItemData) {

	// TODO: This check excludes pickle pee items but also dropped items, which may be desirable
	// for auto-equip mode. Figure out whether to remove it.
	if (*pItemData >= 0) ItemRandomiser->RandomiseItem(pItemBuffer);

	ItemRandomiser->ItemGibOriginal(mapItemMan, pItemBuffer, pItemData);

	if (*pItemData >= 0 && ItemRandomiser->dIsAutoEquip) AutoEquip->AutoEquipItem(pItemBuffer);
}


VOID CItemRandomiser::RandomiseItem(SItemBuffer* pItemBuffer) {

	if (pItemBuffer->length > 6) {
		Core->Panic("Too many items!", "...\\Source\\ItemRandomiser\\ItemRandomiser.cpp", FE_AmountTooHigh, 1);
		int3
	};

	int indexToRemove = -1;
	for (int i = 0; i < pItemBuffer->length; i++) {

		SItemBufferEntry* dItem = &pItemBuffer->items[i];

		spdlog::trace("IN itemID: {}", dItem->id);

		if (dItem->id > (0x40000000 + 3780000)) {
			// If we receive a synthetic item generated by the offline randomizer, it may be a
			// placeholder. If so, we need to replace it with its real equivalent.
			EquipParamGoodsRow* row = GetGoodsParam(dItem->id & 0xfffffffU);
			if (row->iconId == 7039)
			{
				// Notify the server that this location was checked.
				OnGetSyntheticItem(row);
				// If this is a Path of the Dragon replacement, remove it from the item list and grant the
				// gesture manually.
				GameHook->grantPathOfTheDragon();
				indexToRemove = i;
			} else if (row != NULL && row->basicPrice != 0) {
				// Since the function this hooks into only gets called after HookedItemGib, we
				// have to manually make sure it sees the original synthetic item so it can notify
				// the server that the location was checked.
				OnGetSyntheticItem(row);
				dItem->id = row->basicPrice;
				dItem->quantity = row->sellValue;
				dItem->durability = -1;
			}
		}
		else {
			// This is already a vanilla item
		}

		// TODO check randomizer settings and skip if this isn't turned on
		ItemRandomiser->ControlWeaponLevel(dItem);

		spdlog::trace("OUT itemID: {}", dItem->id);
	};

	if (indexToRemove != -1)
	{
		std::memcpy(&pItemBuffer[indexToRemove], &pItemBuffer[indexToRemove + 1],
			(pItemBuffer->length - 1) * sizeof(SItemBufferEntry));
		pItemBuffer->length--;
	}

	return;
}

// Edits the item entry's weapon level based on collected upgrades. does nothing to non-weapon items.
// TODO use "Progressive Upgrade" key items isntead of titanite to prevent player wasting materials.
// that ^ is how i justify this sprawling duplicate code ok? don't judge me
VOID CItemRandomiser::ControlWeaponLevel(SItemBufferEntry* dItem) {

	auto type = ItemInfo->GetWeaponUpgradeType(dItem->id);
	if (!type.has_value())
		return;

	uint32_t upgradeCount;
	bool isSlabEligible = false;
	switch (type.value()) {
		case WeaponUpgradeType::regularInfusible:
		case WeaponUpgradeType::regularUninfusible: {
			spdlog::trace("regular reinforce");

			auto shardId = 0x400003E8;
			auto itemCount = FindUpgradeCount(shardId);
			if (itemCount < 2) {
				upgradeCount = 0;
				break;
			}
			else if (itemCount < 6) {
				upgradeCount = 1;
				break;
			}
			else if (itemCount < 12) {
				upgradeCount = 2;
				break;
			}

			auto largeShardId = 0x400003E9;
			itemCount = FindUpgradeCount(largeShardId);
			if (itemCount < 2) {
				upgradeCount = 3;
				break;
			}
			else if (itemCount < 6) {
				upgradeCount = 4;
				break;
			}
			else if (itemCount < 12) {
				upgradeCount = 5;
				break;
			}

			auto chunckId = 0x400003EA;
			itemCount = FindUpgradeCount(chunckId);
			if (itemCount < 2)
				upgradeCount = 6;
			else if (itemCount < 6)
				upgradeCount = 7;
			else if (itemCount < 12)
				upgradeCount = 8;
			else {
				upgradeCount = 9;
				isSlabEligible = true;
			}
			break;
		}
		case WeaponUpgradeType::twinkling: {
			spdlog::trace("twinkling reinforce");
			auto twinklingId = 0x40000406;
			auto itemCount = FindUpgradeCount(twinklingId);
			if (itemCount < 1)
				upgradeCount = 0;
			else if (itemCount < 3)
				upgradeCount = 1;
			else if (itemCount < 7)
				upgradeCount = 2;
			else if (itemCount < 15)
				upgradeCount = 3;
			else {
				upgradeCount = 4;
				isSlabEligible = true;
			}
			break;
		}
		case WeaponUpgradeType::scale: {
			spdlog::trace("scale reinforce");
			auto scaleId = 0x400003FC;
			auto itemCount = FindUpgradeCount(scaleId);
			if (itemCount < 1)
				upgradeCount = 0;
			else if (itemCount < 3)
				upgradeCount = 1;
			else if (itemCount < 7)
				upgradeCount = 2;
			else if (itemCount < 15)
				upgradeCount = 3;
			else {
				upgradeCount = 4;
				isSlabEligible = true;
			}
			break;
		}
		default: {
			// WeaponUpgradeType::none
			return;
		}
	}

	if (isSlabEligible) {
		auto slabId = 0x400003EB;
		auto itemCount = FindUpgradeCount(slabId);
		if (itemCount > 0)
			upgradeCount++;
	}

	auto baseId = dItem->id - (dItem->id % 100);
	dItem->id = baseId + upgradeCount;
}

// searches the player's inventory for the given item id and returns how many of it there are.
// TODO currently searches itemsAboveCap. but after making key items for progressive upgrades, should use itemsBelowCap
uint32_t CItemRandomiser::FindUpgradeCount(uint32_t dItemID) {

	auto itemList = GameDataMan::instance()->localPlayerData->equipGameData1.equipInventoryData.list;
	for (uint32_t i = 0; i < itemList.slotIdCap; i++) {
		auto item = itemList.itemsAboveCap[i];
		if (item.itemId == dItemID) {
			return item.itemCount;
		}
	}
	return 0;
}

// This function is called once each time the player receives an item with an ID they don't already
// have in their inventory. It's called _after_ HookedItemGib, so it'll only see the items that
// that has replaced.
uint64_t CItemRandomiser::HookedOnGetItem(void* pEquipInventoryData, uint32_t qItemCategory,
		uint32_t qItemID, uint32_t qCount, void* qUnknown2) {
	// This function is frequently called with very high item IDs while the game is loading
	// for unclear reasons. We want to ignore those calls.
	bool removeItem = false;
	if (qItemID < 0xA0000000 && Core->connected) {
		if (qItemCategory == 0 && qItemID > 23010000) {
			EquipParamWeaponRow* row = GetWeaponParam(qItemID & 0xfffffffU - qItemID % 100);
			if (row != NULL) {
				ItemRandomiser->OnGetSyntheticItem(
					row->vagrantItemLotId, row->vagrantBonuseneDropItemLotId);
			}
		} else if (qItemCategory == 0x10000000 && qItemID > 99003000) {
			EquipParamProtectorRow* row = GetProtectorParam(qItemID & 0xfffffffU);
			if (row != NULL) {
				ItemRandomiser->OnGetSyntheticItem(
					row->vagrantItemLotId, row->vagrantBonuseneDropItemLotId);
			}
		}
		else if (qItemCategory == 0x20000000 && qItemID > 3780000) {
			EquipParamAccessoryRow* row = GetAccessoryParam(qItemID & 0xfffffffU);
			if (row != NULL) {
				ItemRandomiser->OnGetSyntheticItem(
					row->vagrantItemLotId, row->vagrantBonusEneDropItemLotId);
			}
		} else if (qItemCategory == 0x40000000 && qItemID > 3780000) {
			EquipParamGoodsRow* row = GetGoodsParam(qItemID & 0xfffffffU);
			if (row != NULL) {
				ItemRandomiser->OnGetSyntheticItem(row);
				removeItem = row->disableUseAtColiseum;
			}
		}
	}

	auto result = ItemRandomiser->OnGetItemOriginal(pEquipInventoryData, qItemCategory, qItemID, qCount, qUnknown2);
	// If the player isn't connected to Archipelago, hold onto foreign items so that we can send
	// them out once they reconnect
	if (removeItem && Core->connected) GameHook->removeFromInventory(qItemCategory, qItemID);
	return result;
}

VOID CItemRandomiser::OnGetSyntheticItem(EquipParamGoodsRow* row) {
	// TODO: We shouldn't call this with non-AP items, but we do sometimes.
	if (row->vagrantItemLotId < 0) return;
	ItemRandomiser->OnGetSyntheticItem(row->vagrantItemLotId, row->vagrantBonusEneDropItemLotId);
}

// Tells the Archipelago server that a synthetic item was aquired (meaning that a location was
// visited and possibly that another world's item was received). The itemID should contain only the
// base ID, not the category flag.
//
// Returns the parameter data about the aquired item.
VOID CItemRandomiser::OnGetSyntheticItem(uint32_t archipelagoId1, uint32_t archipelagoId2) {
	int64_t archipelagoLocationId = archipelagoId1 + ((int64_t)(archipelagoId2) << 32);
	checkedLocationsList.push_front(archipelagoLocationId);
}

VOID CItemRandomiser::sendMissedItems() {
	auto itemList = GameDataMan::instance()->localPlayerData->equipGameData1.equipInventoryData.list;
	for (uint32_t i = 0; i < itemList.slotIdCap; i++) {
		// Key items are always in itemList.itemsBelowCap
		auto item = itemList.itemsBelowCap[i];
		if (item.handle == 0) continue;
		if (item.itemCount == 0) continue;
		auto itemCategory = item.itemId & 0xf0000000;
		auto itemId = item.itemId & 0xfffffff;

		if (itemCategory == 0x40000000 && itemId > 3780000 && itemId < 0xffffffU) {
			EquipParamGoodsRow* row = GetGoodsParam(item.itemId & 0xfffffffU);
			if (row != NULL) ItemRandomiser->OnGetSyntheticItem(row);
			GameHook->removeFromInventory(itemCategory, itemId, 1);
		}
	}
}

